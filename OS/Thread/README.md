# Thread

프로세스 내에서 실행되는 여러 실행 흐름의 단위로서 *프로세스의 특정한 수행 경로* 를 의미함

- [배경과 정의](#배경과-정의)   
    - [동시접속 서버](#concurrent-servers)
    - [멀티 스레드](#multi-thread)
    - [pthreads](#pthreads)
    - [문제점](#문제)
        - [생성](#생성의-문제)
        - [취소](#취소의-문제)
        - [시그널 운용](#시그널-운용-문제)
- [커널 수준/유저 수준 스레드](#커널수준유저수준-스레드)
    - [커널 수준 스레드](#커널-수준-스레드)
    - [유저 수준 스레드](#유저-수준-스레드)
        - [스레드 컨텍스트 스위치](#스레드-컨텍스트-스위치)
        - [한계](#한계)
        - [스레드 스케줄링](#스레드-스케줄링)
# 배경과 정의

하나의 프로세스는 모든 코드와 데이터들을 담은 주소 공간, 운영체제 자원, PC, SP, 레지스터 등의 하드웨어 실행 상태와 같은 많은 것들을 포함하므로, 하나의 새로운 프로세스를 생성하는 것은 많은 비용이 드는 작업임.  따라서 쓰레드 단위로 작업을 관리한다면 운영체제 입장에서는 프로세스 유지에 부담이 있음. 또한 시스템 콜과 데이터 복사의 오버헤드로 인해 프로세스간 커뮤니케이션에도 운영체제의 관여가 필요하기에 비용이 많이 듦.

- **Cooperating Processes**
    
    - 다수의 동시작업을 처리해야 하는 웹서버
    
    - 멀티프로세서에서 돌아가는 병렬 프로그래밍
    
    위와 같은 상황에서 공유 데이터는 같은 주소 공간을 참조하는 병렬적으로 실행되는 몇 개의 프로세스를 만들 필요가 생김 ⇒ 공간적으로나 시간적으로나 매우 비효율적임
    
    - **공유되는 것**
        - 동일한 코드와 데이터 (주소공간)
        - 동일한 특권
        - 동일한 자원들 (파일, 소켓 등)
    - **다른 것**
        
        각각의 프로세스는 각자의 하드웨어 실행상태(컨텍스트)를 지님 (PC, 레지스터들, SP, 스택)
        

이러한 Cooperating Processes에서 각 프로세스의 공유되는 것과 다른 것에 초점을 맞추어 실행상태를 분리하여 만듦. 이때, 이 다른 것에 해당하는 ‘실행 상태’를 스레드라 부름

따라서 여러 개의 스레드가 동시에 동작하는 경우, 각각의 스레드들은 메모리 영역 중 code, data, heap 영역은 공유하며 각자의 하드웨어 스택을 지니게됨

- **구성요소**
    - **PC(Program Counter)**
    - **stack(지역 변수, 함수의 매개변수, 리턴 주소 등)**
    - **registers**
- **특징**
    - **명령어 및 데이터 공유**
        
        한 스레드 내에서 변경된 공유 데이터는 프로세스 내 다른 스레드와 공유함
        
    - **운영체제 상태 공유**
        
        스레드는 프로세스의 대부분의 운영체제 상태를 공유함
        

## Concurrent Servers

동시 접속이 이뤄지는 서버를 구현시 각각의 요청에 대해 새로운 스레드를 생성할 수 있음

- **순서**
    1. 클라이언트가 서버에 요청 전송
    2. 서버는 요청에 대한 서비스를 제공하는 새로운 스레드를 생성
    3. 서버는 클라이언트의 추가적인 요청이 올 때까지 대기
- **멀티 프로세스와의 차이**
    
    ```c
    webserver() {
    	while(1) {
    		int sock = accept(); //요청에 대한 소켓 생성
    		create_thread(handle_request, sock); //스레드 생성
    	}
    }
    /* 해당 소켓에 대한 요청을 처리하는 함수 */
    handle_request(int sock) {
    	//...Process request
    	close(sock);
    }
    ```
    
    ⇒ 서로 다른 스레드는 서로 다른 handle_request를 수행함
    

## Multi-Thread

하나의 프로세스 내에서 여러 개의 스레드를 생성하여 작업을 처리하는 과정으로 하나의 작업을 여러 개의 프로세스 단위로 처리하는 과정인 멀티 프로세스와 같이 여러 개의 작업을 병렬적으로 처리함으로써 작업속도를 높일 수 있음

> **멀티 프로세스의 문제점**
> 
> - **잦은 컨텍스트 스위치**
> - **프로세스 간 통신**
> - **많은 메모리 공간 소요**
- **장점**
    - **병렬적 처리**
        
        멀티프로세서 구조를 이용하여 병령 프로그래밍을 가능케 함
        
    - **저렴한 동시성 생성**
        - **시간 비용**
            
            프로세스의 컨텍스트 스위치와 달리 캐시 메모리를 비울 필요가 없기 때문에 CPU의 처리 속도가 빨라져 프로그램의 응답시간이 단축됨
            
        - **메모리 비용**
            
            하나의 프로세스 내에서 메모리 공간을 공유하여 멀티 프로세스에 비해서 메모리 소비가 적음
            
    - **자원 공유**
        
        별도의 통신 방법이나 자원 없이 공유하는 메모리 영역을 통해서 데이터를 주고 받을 수 있음
        
    - **높은 처리량**
        
        I/O 동작을 수반하는 중복계산으로 전체적인 처리량이 프로세스를 생성하는 fork()보다 높음
        
    - **좋은 응답성**
        
        웹 서버 등에서 동시 이벤트를 처리할 수 있음
        

## pthreads

pthreads는 스레드 생성과 동기화를 위한 POSIX 표준 API로 스레드 라이브러리의 행위를 명시함

> **POSIX vs Microsoft**
> 
> 
> pthreads는 POSIX 스타일의 스레드는 초기 pthreads 버전인 DCE threads와 Unix International threads (Solaris threads)가 합쳐져 만들어짐. Win32 threads, OS/2 threads의 Microsoft의 스타일의 스레드도 존재
> 
- **예시**
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    
    void *threadfunc(void* vargp);
    
    /*thread routine*/
    void* threadfunc(void* vargp) {
    	sleep(1);
    	printf("Hello, world!\n");
    	return NULL;
    }
    
    int main() {
    	pthread_t tid;
    	
    	pthread_create(&tid, NULL, threadfunc, NULL); //스레드 생성
    	printf("main\n");
    	pthread_join(tid, NULL); //스레드 종료시까지 대기
    	printf("main2\n");
    	sleep(2);
    	return 0;
    }
    ```
    
    1. “main” 출력
    2. “Hello,  world!” 출력
    3. “main2” 출력

## 문제

### 생성의 문제

- **fork()**
    
    스레드가 fork()를 호출하면
    
    - 기존의 모든 스레드들을 복제하거나
    - 단일 스레드(fork()를 호출한 스레드)의
    
    새로운 프로세스를 생성할 수 있음
    
    ⇒ 몇몇의 UNIX 시스템들은 두 가지 모두를 지원함
    
    - **pthreads**
        
        fork() ⇒ 부른 스레드만 복제
        
    - **Unix international standard**
        
        fork() ⇒ 모든 스레드를 복제 / fork1() ⇒ 부른 스레드만 복제
        
- **exec()**
    
    기존의 exec()과 마찬가지로 동작함 ⇒ 스레드를 모두 죽이고 완전히 다른 프로그램으로 대체시킴
    

> **exit(), main의 return**
> 
> 
> exit() 호출시 프로세스 전체가 종료됨
> 
> main의 return이 자식보다 먼저 종료보다 먼저 실행되면 프로세스 전체가 종료됨
> 

### 취소의 문제

- **비동기적 취소**
    
    목표 스레드를 바로 죽임
    
- **지연 취소**
    
    목표 스레드가 종료 시점에 종료됨 ⇒ 종료 여부를 주기적으로 확인함
    

pthreads API는 비동기적 취소, 지연 취소 모두 지원함

### 시그널 운용 문제

어디로 시그널이 보내져야 할지에 대한 문제임

- **시그널 적용 스레드**
    
    동기적 시그널을 시그널이 적용되는 스레드로 보내짐
    
- **모든 스레드**
- **특정 스레드**
    
    시그널을 막지 않는 특정 스레드에 시그널을 보냄
    

# 커널수준/유저수준 스레드

운영체제는 사용자 인터페이스에 대한 편리성과 안정성을 위해 CPU를 스레드를 생성하고 관리하는데 누가 책임을 지느냐에 따라 kernel threads와 user-level threads로 나눌 수 있음

## 커널 수준 스레드

스레드 생성 및 관리를 위해 운영체제는 커널 내부의 system call을 해야 함 ⇒ 모든 스레드 동작은 커널 내부에서 수행되며 운영체제가 시스템의 모든 스레드들의 스케줄을 관리함

- **한계**
    - **비용 문제**
    - **시스템 콜**
        
        프로그램이 모든 스레드 동작마다 매번 추가 보호 경계를 넘나들어야 함 (같은 주소 공간 내 스레드 간에도 CPU의 스위칭 작업이 필요)
        
    - **커널 상태 유지**
        
        각 스레드마다 커널 상태를 유지해야 함
        

## 유저 수준 스레드

프로그램에 링크된 라이브러리가 스레드를 관리함

커널 스레드의 비용 문제로 인해 스레드 생성 및 관리를 유저 단에서 처리할 필요가 생김

- **특징**
    - **운용성**
        
        운영체제에 의존하는 커널 스레드에 비해, 컴파일만 되면 해당 시스템에서 운용 가능함
        
    - **작은 TCB**
    - **함수 호출**
        
        system call(커널 개입)을 하는 커널 스레드와 달리 스레드 생성, 스레드 스위칭, 동기화 등이 함수 호출에 의해 이루어짐
        

### **스레드 컨텍스트 스위치**

현재 실행 중인 스레드의 컨텍스트를 저장(모든 하드웨어 상태를 스택에 push) 후, 다음 실행할 스레드의 컨텍스트를 복구(스레드의 스택으로부터 하드웨어 상태를 pop)하는 과정의 반복으로 이루어짐

- **스레드 테이블**
    
    프로세스 내부에는 라이브러리로서 작용하는 런타임 시스템이 존재하며, 이 시스템이 스레드 테이블을 관리함 
    

### **한계**

운영체제는 프로세스 테이블만 관리할 수 있으며, 내부 상황(스레드 생성 및 관리와 관련한 상황)을 알 수 없음 ⇒ 운영체제가 잘못된 결정을 내릴 수 있음

- 쉬고 있는 스레드에 cpu 할당 (실제로는 ‘프로세스’에 할당)

- 실행 준비된 다른 스레드가 있음에도, 스레드가 I/O를 시작한 프로세스 실행을 중단

- lock이 걸린 스레드를 가진 프로세스를 unschedule함

### **스레드 스케줄링**

런타임 라이브러리로서 유저 수준에서 실행되는 스레드 스케줄러가 스레드 스케줄링을 담당

- **내부의 큐**
    
    내부에 큐를 두어 관리
    
    - **Run queue**
        
        현재 실행되는 스레드
        
    - **Ready queue**
        
        실행 준비의 스레드
        
    - **Wait queue**
        
        대기 상태가 된 스레드
        
- **비선점 스케줄링**
    
    런타임 라이브러리는 스레드의 cpu 점유시간을 강제하지 못함 ⇒ 모든 스레드가 cpu 점유시간을 적절히 사용할 수 있게 협조를 구해야 함
    
    - **`yield()`**
        
        위 사항을 프로그래밍적으로 구현한 함수로, 스레드 내에서 이 함수 호출 시 해당 스레드는 cpu 점유를 포기함 ⇒ 컨텍스트 스위칭하기 위해 사용됨
        
        > **스레드 무한루프**
        > 
        > 
        > 한 스레드에서 yield()를 호출하지 않을 시 해당 스레드가 무한 반복되는 문제가 발생할 수 있음
        > 
- **선점 스케줄링**
    
    런타임 라이브러리가 cpu의 동작을 비동기적으로 위임받음 ⇒ 스레드의 cpu 점유를 강제로 뺏음
    
    - **Signal**
        
        스케줄러는 OS가 주기적으로 타이머 인터럽트를 제공하도록 요청하며, 시그널은 소프트웨어 인터럽트와 같음 ⇒ 매 타이머 인터럽트마다 스케줄러는 통제를 얻고 적절한 컨텍스트 스위치를 함 
        
        - 유저 수준으로 제공됨 (OS로 제공되는게 아님)
        
        - 주로 UNIX 시그널로 제공됨